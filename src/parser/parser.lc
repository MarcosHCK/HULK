-- Copyright 2021-2025
-- This file is part of HULK.
--
-- HULK is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- HULK is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with HULK.  If not, see <http://www.gnu.org/licenses/>.
--
algorithm ('lr')
generator ('python')

prolog ('prolog.py')

local function pythonize (v)

  if (type (v) == 'boolean') then return v == true and 'True' or 'False'
  elseif (type (v) == 'table') then error ('untranslatable value')
  else return tostring (v) end
end

local function builder (funcname, ...)

  local args = ''
  for _, a in ipairs ({...}) do args = args .. ',' .. pythonize (a) end

  local line1 = ('from parser.builder import %s'):format (funcname)
  local line2 = ('return %s (args%s)'):format (funcname, args)
  return verbatim (line1, line2)
end

local function beginlist (a) return builder ('build_list_begin', a) end
local function emptylist () return builder ('build_list_empty') end
local function joinlist (a, b) return builder ('build_list_join', a, b) end
local function nextlist (a, b) return builder ('build_list_next', a, b) end
local function pickarg (a) return builder ('build_pickarg', a) end

--
-- Actual grammar
--

BOOLEAN_VALUE = token ()
NUMBER_VALUE = token ()
STRING_VALUE = token ()

IDENTIFIER = token ()

--
-- Global
--

file = global_block

global_block = global_stmtlist                                                    / builder ('build_block')

global_stmtlist = (global_stmt + global_stmtlist)                                 / nextlist (0, 1)
global_stmtlist = global_stmt                                                     / beginlist (0)

global_stmt = funcdecl * protodecl * typedecl
global_stmt = single_block

--
-- Function declaration
--

funcdecl = (funcdecl_head + params + inline_block)                                / builder ('build_function_decl', false)
funcdecl = (funcdecl_head + params + keyed_block)                                 / builder ('build_function_decl', false)

funcdecl_head = (literal 'function' + IDENTIFIER)                                 / pickarg (1)

inline_block = (literal '=>' + block)                                             / pickarg (1)

params = (literal '(' + paramlist + ')')                                          / pickarg (1)
params = (literal '(' + ')')                                                      / emptylist ()

paramlist = (param + ',' + paramlist)                                             / nextlist (0, 2)
paramlist = param                                                                 / beginlist (0)

param = (IDENTIFIER + ':' + IDENTIFIER + '[' + ']')                               / builder ('build_param', true, true)
param = (IDENTIFIER + ':' + IDENTIFIER)                                           / builder ('build_param', true, false)
param = IDENTIFIER                                                                / builder ('build_param', false, false)

--
-- Protocols
--

protodecl = (protodecl_head + protodecl_block)                                    / builder ('build_protocol_decl', false)
protodecl = (protodecl_head + protodecl_derv + protodecl_block)                   / builder ('build_protocol_decl', true)

protodecl_head = (literal 'protocol' + IDENTIFIER)                                / pickarg (1)
protodecl_derv = (literal 'extends' + IDENTIFIER)                                 / pickarg (1)

protodecl_block = protodecl_stmts                                                 / builder ('build_block')

protodecl_stmts = ('{' + protodecl_stmtlist + '}')                                / pickarg (1)

protodecl_stmtlist = (protodecl_stmt + protodecl_stmtlist)                        / nextlist (0, 1)
protodecl_stmtlist = protodecl_stmt                                               / beginlist (0)

protodecl_stmt = (protodecl_attribute + ';')                                      / pickarg (0)
protodecl_stmt = (protodecl_method + ';')                                         / pickarg (0)

protodecl_method = (IDENTIFIER + protodecl_params)                                / builder ('build_function_decl', true)

protodecl_attribute = protodecl_param

protodecl_params = (literal '(' + protodecl_paramlist + ')')                      / pickarg (1)
protodecl_params = (literal '(' + ')')                                            / emptylist ()

protodecl_paramlist = (protodecl_param + ',' + protodecl_paramlist)               / nextlist (0, 2)
protodecl_paramlist = protodecl_param                                             / beginlist (0)

protodecl_param = (IDENTIFIER + ':' + IDENTIFIER + '[' + ']')                     / builder ('build_param', true, true)
protodecl_param = (IDENTIFIER + ':' + IDENTIFIER)                                 / builder ('build_param', true, false)

--
-- Types
--

typedecl = (typedecl_head + typedecl_block)                                       / builder ('build_type_decl', false)
typedecl = (typedecl_head + typedecl_derv + typedecl_block)                       / builder ('build_type_decl', true)

typedecl_head = (literal 'type' + IDENTIFIER)                                     / pickarg (1)
typedecl_derv = (literal 'inherits' + IDENTIFIER)                                 / pickarg (1)

typedecl_block = typedecl_stmts                                                   / builder ('build_block')

typedecl_stmts = ('{' + typedecl_stmtlist + '}')                                  / pickarg (1)

typedecl_stmtlist = (typedecl_stmt + typedecl_stmtlist)                           / nextlist (0, 1)
typedecl_stmtlist = typedecl_stmt                                                 / beginlist (0)

typedecl_stmt = typedecl_attribute
typedecl_stmt = typedecl_method

typedecl_method = (IDENTIFIER + params + inline_block)                            / builder ('build_function_decl', false)
typedecl_method = (IDENTIFIER + params + keyed_block)                             / builder ('build_function_decl', false)

typedecl_attribute = (param + '=' + stmt)                                         / builder ('build_varparam')

--
-- Construct block
--

construct_block = keyed_stmts                                                     / builder ('build_block')
construct_block = construct_stmt                                                  / builder ('build_block')

construct_stmt = expression                                                       / beginlist (0)

--
-- Conditional
--

if_ = ifelse_list                                                                 / builder ('build_conditional')

ifelse_list = (if_list + else_list)                                               / joinlist (0, 1)

if_list = (if_stmt + elif_list)                                                   / nextlist (0, 1)
if_list = if_stmt                                                                 / beginlist (0)

elif_list = (elif_stmt + elif_list)                                               / nextlist (0, 1)
elif_list = elif_stmt                                                             / beginlist (0)

else_list = else_stmt                                                             / beginlist (0)

if_stmt = (if_head + construct_block)                                             / builder ('build_conditional_entry', false)
elif_stmt = (elif_head + construct_block)                                         / builder ('build_conditional_entry', false)
else_stmt = (else_head + construct_block)                                         / builder ('build_conditional_entry', true)

if_head = (literal 'if' + parenthized)                                            / pickarg (1)
elif_head = (literal 'elif' + parenthized)                                        / pickarg (1)
else_head = literal 'else'

--
-- Let
--

let = (literal 'let' + let_varlist + 'in' + construct_block)                      / builder ('build_let')

let_varlist = (let_var + ',' + let_varlist)                                       / nextlist (0, 2)
let_varlist = let_var                                                             / beginlist (0)

let_var = (param + '=' + expression)                                              / builder ('build_varparam')

--
-- Loop (for)
--

for_ = (for_head + construct_block)                                               / builder ('build_for')

for_head = (literal 'for' + for_param)                                            / pickarg (1)
for_param = ('(' + for_var + ')')                                                 / pickarg (1)
for_var = (param + 'in' + expression)                                             / builder ('build_varparam')

--
-- Loop (while)
--

while_ = (while_head + construct_block)                                           / builder ('build_while')
while_head = (literal 'while' + parenthized)                                      / pickarg (1)

--
-- Blocks
--

block = keyed_block
block = single_block

keyed_block = (keyed_stmts + ';')                                                 / builder ('build_block')
keyed_block = keyed_stmts                                                         / builder ('build_block')
single_block = single_stmt                                                        / builder ('build_block')

keyed_stmts = ('{' + stmtlist + '}')                                              / pickarg (1)
single_stmt = stmt                                                                / beginlist (0)

stmtlist = (stmt + stmtlist)                                                      / nextlist (0, 1)
stmtlist = stmt                                                                   / beginlist (0)

stmt = (expression + ';')                                                         / pickarg (0)

--
-- Expressions
--

expression = (literal '!' + expression)                                           / builder ('build_unary_operator')
expression = disjuntive

disjuntive = (disjuntive + '|' + conjuntive)                                      / builder ('build_binary_operator')
disjuntive = conjuntive

conjuntive = (conjuntive + '&' + boolean)                                         / builder ('build_binary_operator')
conjuntive = boolean

boolean = (boolean + (literal '<' * '>' * '<=' * '>=' * '==' * '!=') + concated)  / builder ('build_binary_operator')
boolean = concated

concated = (numeric + (literal '@' + '@@') + concated)                            / builder ('build_binary_operator')
concated = numeric

numeric = (numeric + (literal '+' * '-') + term)                                  / builder ('build_binary_operator')
numeric = term

term = (term + (literal '*' * '/' * '%') + factor)                                / builder ('build_binary_operator')
term = factor

factor = (power + (literal '^') + factor)                                         / builder ('build_binary_operator')
factor = power

power = BOOLEAN_VALUE                                                             / builder ('build_boolean_value')
power = NUMBER_VALUE                                                              / builder ('build_number_value')
power = STRING_VALUE                                                              / builder ('build_string_value')
power = IDENTIFIER                                                                / builder ('build_var_value')
power = parenthized
power = (IDENTIFIER + args)                                                       / builder ('build_invoke')

power = let
power = if_
power = for_
power = while_

arglist = (expression + ',' + arglist)                                            / nextlist (0, 2)
arglist = expression                                                              / beginlist (0)

args = (literal '(' + arglist + ')')                                              / pickarg (1)
args = (literal '(' + ')')                                                        / emptylist ()

parenthized = ('(' + expression + ')')                                            / pickarg (1)
